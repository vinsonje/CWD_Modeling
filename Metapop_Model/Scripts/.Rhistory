SS.event.out = sharpshootingCWD(pop, centroids, surv.yearly, ss.shooters, ss.times, ss.radius, ss.eff, ss.strat, i)
pop = SS.event.out[[1]]
surv.yearly = SS.event.out[[2]]
SS.out = rbind(SS.out, SS.event.out[[3]])
################################
###########Summarize############
################################
print("Summarizing")
summary.pop = summarizeCWD(pop, track.pop, i)
Ssums[i,] = summary.pop[[1]]
Esums[i,] = summary.pop[[2]]
Isums[i,] = summary.pop[[3]]
Scells[i,] = summary.pop[[4]]
Ecells[i,] = summary.pop[[5]]
Icells[i,] = summary.pop[[6]]
I_locs[[i]] = summary.pop[[7]]
Spread[i,] = summary.pop[[8]]
Nall[i,] = summary.pop[[9]]
pop.out = rbind(pop.out, summary.pop[[10]])
landscape.prions.temp = data.frame(landscape.prions, time = rep(i, dim(landscape.prions)[1]))
landscape.prions.out = rbind(landscape.prions.out, landscape.prions.temp)
}else{print("Exiting loop, no infections")} #if any infected closing bracket/else
} #for timestep closing bracket
track.pop = TRUE
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWDparms.R", echo=TRUE)
#load in parmeters
source(paste(getwd(), "/CWDParms.R", sep = ''))
#determine cells
cells = dim(centroids)[1]
###########################################
####### Initialize Tracked Objects ########
###########################################
#track total abundance
Nall = matrix(0, nrow = thyme)
Nall[1] = sum(pop[,1])
#track births
BB = matrix(0, nrow = thyme)
#number of infected cells, area of infection, max distance between any two cases
Spread = matrix(0, nrow = thyme, ncol = 3)
#store new cases for each time step
Incidence = matrix(0, nrow = thyme)
Incidence[1] = I0
#track the locations of cells with I
I_locs = vector("list", thyme)
I_locs[1:thyme] = NA
#track the number of SEI individuals
Ssums = matrix(0, nrow = thyme, ncol = 1)
Esums = matrix(0, nrow = thyme, ncol = 1)
Isums = matrix(0, nrow = thyme)
#track the number of cells with SEI individuals
Scells = matrix(0, nrow = thyme, ncol = 1)
Ecells = matrix(0, nrow = thyme, ncol = 1)
Icells = matrix(0, nrow = thyme)
#initialize the prions
landscape.prions.out = data.frame(landscape.prions, time = rep(0, dim(landscape.prions)[1]))
#harvest
harvest.out = matrix(0, ncol = 5)
harvest.yearly = matrix(0, ncol = 5)
#total pop data
pop.out = cbind(pop, time = 0)
#surveillence data
surv.out = NULL
surv.yearly = NULL
#SS data
SS.out = NULL
##################################
######## Start simulation ########
##################################
#start the timestep loop
for(i in 1:thyme){
if (any(pop[, 9, drop=FALSE]!=0|pop[, 10, drop=FALSE]!=0)){
# if (any(pop[, 9, drop=FALSE]>-999|pop[, 10, drop=FALSE]>-999)){
print(i)
##########################
######## Movement ########
##########################
print("starting movement")
pop = FastMovementCWD(pop, centroids, shift, inc, max.den, move.strat)
###############################
######## State Changes ########
###############################
print("starting state changes")
#births, natural deaths, disease state changes (exposure, infection, recovery, death), carcass decay
st.list = StateChangesCWD(pop, centroids, cells,
Pbd,
B1, F1, F2,
B1P.m, B1P.inter, F2i,
K, lifespan, lat.period, inf.period,
Incidence, BB, i,
landscape.prions)
pop = st.list[[1]]
Incidence = st.list[[2]]
BB = st.list[[3]]
################################
####### Shedding ###############
################################
print("starting shedding")
landscape.prions = shedCWD(pop, landscape.prions, shed)
################################
####### Corpse Burst ###########
################################
print("starting corpse burst")
corpse.burst.out = corpse_burstCWD(pop, landscape.prions, corpse.burst)
pop = corpse.burst.out[[1]]
landscape.prions = corpse.burst.out[[2]]
################################
####### Removal of prions #######
################################
print("starting prions removal")
landscape.prions = prion.removal(landscape.prions, prion.lifespan)
##############################
######### Harvesting #########
##############################
print("starting harvesting")
harvest.event.out = harvestingCWD(pop, centroids, h.permits, h.times, h.radius, h.num, i)
pop = harvest.event.out[[1]]
harvest.out = rbind(harvest.out, harvest.event.out[[2]])
harvest.yearly = rbind(harvest.yearly, harvest.event.out[[2]])
##############################
######### Surveillance #######
##############################
print("starting surveillance")
surv.event.out = surveillance.fun(harvest.yearly, test.rate, true.pos.E, true.pos.I, true.neg, sur.start, i)
surv.yearly = rbind(surv.yearly, surv.event.out[[1]])
harvest.yearly = surv.event.out[[2]]
surv.out = rbind(surv.out, surv.event.out[[1]])
###############################
#### Sharpshooting ############
###############################
print("starting sharpshooting")
SS.event.out = sharpshootingCWD(pop, centroids, surv.yearly, ss.shooters, ss.times, ss.radius, ss.eff, ss.strat, i)
pop = SS.event.out[[1]]
surv.yearly = SS.event.out[[2]]
SS.out = rbind(SS.out, SS.event.out[[3]])
################################
###########Summarize############
################################
print("Summarizing")
summary.pop = summarizeCWD(pop, track.pop, i)
Ssums[i,] = summary.pop[[1]]
Esums[i,] = summary.pop[[2]]
Isums[i,] = summary.pop[[3]]
Scells[i,] = summary.pop[[4]]
Ecells[i,] = summary.pop[[5]]
Icells[i,] = summary.pop[[6]]
I_locs[[i]] = summary.pop[[7]]
Spread[i,] = summary.pop[[8]]
Nall[i,] = summary.pop[[9]]
pop.out = rbind(pop.out, summary.pop[[10]])
landscape.prions.temp = data.frame(landscape.prions, time = rep(i, dim(landscape.prions)[1]))
landscape.prions.out = rbind(landscape.prions.out, landscape.prions.temp)
}else{print("Exiting loop, no infections")} #if any infected closing bracket/else
} #for timestep closing bracket
pop
harvest.event.out = harvestingCWD(pop, centroids, h.permits, h.times, h.radius, h.num, i)
pop.out = pop
harvest.out = matrix(c(0, 0, 0, 0, 0), nrow = 1)
if(thyme %in% h.time){
print("starting harvest")
h.loc = sample(dim(centroids)[1], h.permits, replace = TRUE)
for(q in 1:length(h.loc)){
h.loc.id.now = h.loc[q]
h.loc.xloc.now = centroids[h.loc.id.now, 1]
h.loc.yloc.now = centroids[h.loc.id.now, 2]
cells.in.h.radius = NULL
for(w in 1:dim(centroids)[1]){
potential.cell.x = centroids[w,1]
potential.cell.y = centroids[w,2]
distance = sqrt((h.loc.xloc.now - potential.cell.x)^2 + (h.loc.yloc.now - potential.cell.y)^2)
if(distance <= h.radius){
# print("true")
cells.in.h.radius = append(cells.in.h.radius, w)
}
}#end of distance calc loop
fams.in.radius = intersect(pop.out[,3], cells.in.h.radius)
# print(paste("removing", length(fams.in.radius), "families"))
fams.rem.index = which(pop[,3] %in% fams.in.radius)
pop.sub = pop[fams.rem.index, , drop = FALSE]
pop.classes = colSums(pop.sub[,8:10, drop = FALSE])
deer.in.sub = rep(c("S", "E", "I"), pop.classes)
S.in.sub = rep(pop.sub[,3], pop.sub[,8])
E.in.sub = rep(pop.sub[,3], pop.sub[,9])
I.in.sub = rep(pop.sub[,3], pop.sub[,10])
if(h.num > length(deer.in.sub)){h.num = length(deer.in.sub)}
rem.mems = sample(deer.in.sub, h.num, replace = FALSE)
S.rem = length(which(rem.mems == "S"))
E.rem = length(which(rem.mems == "E"))
I.rem = length(which(rem.mems == "I"))
S.rem.loc = sample(S.in.sub, S.rem, replace = FALSE)
E.rem.loc = sample(E.in.sub, E.rem, replace = FALSE)
I.rem.loc = sample(I.in.sub, I.rem, replace = FALSE)
S.rem.ct = data.frame(table(S.rem.loc))
E.rem.ct = data.frame(table(E.rem.loc))
I.rem.ct = data.frame(table(I.rem.loc))
for(f in 1:length(fams.rem.index)){
S.rem = 0
E.rem = 0
I.rem = 0
loc = pop[fams.rem.index[f], 3]
if(loc %in% S.rem.ct$S.rem.loc){S.rem = S.rem.ct$Freq[which(S.rem.ct$S.rem.loc==loc)]}
if(loc %in% E.rem.ct$E.rem.loc){E.rem = E.rem.ct$Freq[which(E.rem.ct$E.rem.loc==loc)]}
if(loc %in% I.rem.ct$I.rem.loc){I.rem = I.rem.ct$Freq[which(I.rem.ct$I.rem.loc==loc)]}
pop.out[fams.rem.index[f], 8] = pop.out[fams.rem.index[f], 8] - S.rem
pop.out[fams.rem.index[f], 9] = pop.out[fams.rem.index[f], 9] - E.rem
pop.out[fams.rem.index[f], 10] = pop.out[fams.rem.index[f], 10] - I.rem
pop.out[fams.rem.index[f], 1] = sum(pop.out[fams.rem.index[f], 8:10])
harvest.out.temp = c(time = thyme, loc = loc, S = S.rem, E = E.rem, I = I.rem)
harvest.out = rbind(harvest.out, harvest.out.temp)
} #end for loop to remove individuals from each cell
}#end of h.loc loop
pop.out = pop.out[which(pop.out[,1]>0),]
harvest.out = harvest.out[which(rowSums(harvest.out[,3:5, drop = FALSE])>0), , drop = FALSE]
}#end of h.time if
h.time = h.times
pop.out = pop
harvest.out = matrix(c(0, 0, 0, 0, 0), nrow = 1)
if(thyme %in% h.time){
print("starting harvest")
h.loc = sample(dim(centroids)[1], h.permits, replace = TRUE)
for(q in 1:length(h.loc)){
h.loc.id.now = h.loc[q]
h.loc.xloc.now = centroids[h.loc.id.now, 1]
h.loc.yloc.now = centroids[h.loc.id.now, 2]
cells.in.h.radius = NULL
for(w in 1:dim(centroids)[1]){
potential.cell.x = centroids[w,1]
potential.cell.y = centroids[w,2]
distance = sqrt((h.loc.xloc.now - potential.cell.x)^2 + (h.loc.yloc.now - potential.cell.y)^2)
if(distance <= h.radius){
# print("true")
cells.in.h.radius = append(cells.in.h.radius, w)
}
}#end of distance calc loop
fams.in.radius = intersect(pop.out[,3], cells.in.h.radius)
# print(paste("removing", length(fams.in.radius), "families"))
fams.rem.index = which(pop[,3] %in% fams.in.radius)
pop.sub = pop[fams.rem.index, , drop = FALSE]
pop.classes = colSums(pop.sub[,8:10, drop = FALSE])
deer.in.sub = rep(c("S", "E", "I"), pop.classes)
S.in.sub = rep(pop.sub[,3], pop.sub[,8])
E.in.sub = rep(pop.sub[,3], pop.sub[,9])
I.in.sub = rep(pop.sub[,3], pop.sub[,10])
if(h.num > length(deer.in.sub)){h.num = length(deer.in.sub)}
rem.mems = sample(deer.in.sub, h.num, replace = FALSE)
S.rem = length(which(rem.mems == "S"))
E.rem = length(which(rem.mems == "E"))
I.rem = length(which(rem.mems == "I"))
S.rem.loc = sample(S.in.sub, S.rem, replace = FALSE)
E.rem.loc = sample(E.in.sub, E.rem, replace = FALSE)
I.rem.loc = sample(I.in.sub, I.rem, replace = FALSE)
S.rem.ct = data.frame(table(S.rem.loc))
E.rem.ct = data.frame(table(E.rem.loc))
I.rem.ct = data.frame(table(I.rem.loc))
for(f in 1:length(fams.rem.index)){
S.rem = 0
E.rem = 0
I.rem = 0
loc = pop[fams.rem.index[f], 3]
if(loc %in% S.rem.ct$S.rem.loc){S.rem = S.rem.ct$Freq[which(S.rem.ct$S.rem.loc==loc)]}
if(loc %in% E.rem.ct$E.rem.loc){E.rem = E.rem.ct$Freq[which(E.rem.ct$E.rem.loc==loc)]}
if(loc %in% I.rem.ct$I.rem.loc){I.rem = I.rem.ct$Freq[which(I.rem.ct$I.rem.loc==loc)]}
pop.out[fams.rem.index[f], 8] = pop.out[fams.rem.index[f], 8] - S.rem
pop.out[fams.rem.index[f], 9] = pop.out[fams.rem.index[f], 9] - E.rem
pop.out[fams.rem.index[f], 10] = pop.out[fams.rem.index[f], 10] - I.rem
pop.out[fams.rem.index[f], 1] = sum(pop.out[fams.rem.index[f], 8:10])
harvest.out.temp = c(time = thyme, loc = loc, S = S.rem, E = E.rem, I = I.rem)
harvest.out = rbind(harvest.out, harvest.out.temp)
} #end for loop to remove individuals from each cell
}#end of h.loc loop
pop.out = pop.out[which(pop.out[,1]>0),]
harvest.out = harvest.out[which(rowSums(harvest.out[,3:5, drop = FALSE])>0), , drop = FALSE]
}#end of h.time if
rownames(harvest.out) = NULL
pop.out = pop
harvest.out = matrix(c(0, 0, 0, 0, 0), nrow = 1)
if(thyme %in% h.time){
print("starting harvest")
h.loc = sample(dim(centroids)[1], h.permits, replace = TRUE)
for(q in 1:length(h.loc)){
h.loc.id.now = h.loc[q]
h.loc.xloc.now = centroids[h.loc.id.now, 1]
h.loc.yloc.now = centroids[h.loc.id.now, 2]
cells.in.h.radius = NULL
for(w in 1:dim(centroids)[1]){
potential.cell.x = centroids[w,1]
potential.cell.y = centroids[w,2]
distance = sqrt((h.loc.xloc.now - potential.cell.x)^2 + (h.loc.yloc.now - potential.cell.y)^2)
if(distance <= h.radius){
# print("true")
cells.in.h.radius = append(cells.in.h.radius, w)
}
}#end of distance calc loop
fams.in.radius = intersect(pop.out[,3], cells.in.h.radius)
# print(paste("removing", length(fams.in.radius), "families"))
fams.rem.index = which(pop[,3] %in% fams.in.radius)
pop.sub = pop[fams.rem.index, , drop = FALSE]
pop.classes = colSums(pop.sub[,8:10, drop = FALSE])
deer.in.sub = rep(c("S", "E", "I"), pop.classes)
S.in.sub = rep(pop.sub[,3], pop.sub[,8])
E.in.sub = rep(pop.sub[,3], pop.sub[,9])
I.in.sub = rep(pop.sub[,3], pop.sub[,10])
if(h.num > length(deer.in.sub)){h.num = length(deer.in.sub)}
rem.mems = sample(deer.in.sub, h.num, replace = FALSE)
S.rem = length(which(rem.mems == "S"))
E.rem = length(which(rem.mems == "E"))
I.rem = length(which(rem.mems == "I"))
S.rem.loc = sample(S.in.sub, S.rem, replace = FALSE)
E.rem.loc = sample(E.in.sub, E.rem, replace = FALSE)
I.rem.loc = sample(I.in.sub, I.rem, replace = FALSE)
S.rem.ct = data.frame(table(S.rem.loc))
E.rem.ct = data.frame(table(E.rem.loc))
I.rem.ct = data.frame(table(I.rem.loc))
for(f in 1:length(fams.rem.index)){
S.rem = 0
E.rem = 0
I.rem = 0
loc = pop[fams.rem.index[f], 3]
if(loc %in% S.rem.ct$S.rem.loc){S.rem = S.rem.ct$Freq[which(S.rem.ct$S.rem.loc==loc)]}
if(loc %in% E.rem.ct$E.rem.loc){E.rem = E.rem.ct$Freq[which(E.rem.ct$E.rem.loc==loc)]}
if(loc %in% I.rem.ct$I.rem.loc){I.rem = I.rem.ct$Freq[which(I.rem.ct$I.rem.loc==loc)]}
pop.out[fams.rem.index[f], 8] = pop.out[fams.rem.index[f], 8] - S.rem
pop.out[fams.rem.index[f], 9] = pop.out[fams.rem.index[f], 9] - E.rem
pop.out[fams.rem.index[f], 10] = pop.out[fams.rem.index[f], 10] - I.rem
pop.out[fams.rem.index[f], 1] = sum(pop.out[fams.rem.index[f], 8:10])
harvest.out.temp = c(time = thyme, loc = loc, S = S.rem, E = E.rem, I = I.rem)
harvest.out = rbind(harvest.out, harvest.out.temp)
} #end for loop to remove individuals from each cell
}#end of h.loc loop
pop.out = pop.out[which(pop.out[,1]>0),]
harvest.out = harvest.out[which(rowSums(harvest.out[,3:5, drop = FALSE])>0), , drop = FALSE]
}#end of h.time if
rownames(harvest.out) = NULL
pop.out = pop
harvest.out = matrix(c(0, 0, 0, 0, 0), nrow = 1)
if(thyme %in% h.time){
print("starting harvest")
h.loc = sample(dim(centroids)[1], h.permits, replace = TRUE)
for(q in 1:length(h.loc)){
h.loc.id.now = h.loc[q]
h.loc.xloc.now = centroids[h.loc.id.now, 1]
h.loc.yloc.now = centroids[h.loc.id.now, 2]
cells.in.h.radius = NULL
for(w in 1:dim(centroids)[1]){
potential.cell.x = centroids[w,1]
potential.cell.y = centroids[w,2]
distance = sqrt((h.loc.xloc.now - potential.cell.x)^2 + (h.loc.yloc.now - potential.cell.y)^2)
if(distance <= h.radius){
# print("true")
cells.in.h.radius = append(cells.in.h.radius, w)
}
}#end of distance calc loop
fams.in.radius = intersect(pop.out[,3], cells.in.h.radius)
# print(paste("removing", length(fams.in.radius), "families"))
fams.rem.index = which(pop[,3] %in% fams.in.radius)
pop.sub = pop[fams.rem.index, , drop = FALSE]
pop.classes = colSums(pop.sub[,8:10, drop = FALSE])
deer.in.sub = rep(c("S", "E", "I"), pop.classes)
S.in.sub = rep(pop.sub[,3], pop.sub[,8])
E.in.sub = rep(pop.sub[,3], pop.sub[,9])
I.in.sub = rep(pop.sub[,3], pop.sub[,10])
if(h.num > length(deer.in.sub)){h.num = length(deer.in.sub)}
rem.mems = sample(deer.in.sub, h.num, replace = FALSE)
S.rem = length(which(rem.mems == "S"))
E.rem = length(which(rem.mems == "E"))
I.rem = length(which(rem.mems == "I"))
S.rem.loc = sample(S.in.sub, S.rem, replace = FALSE)
E.rem.loc = sample(E.in.sub, E.rem, replace = FALSE)
I.rem.loc = sample(I.in.sub, I.rem, replace = FALSE)
S.rem.ct = data.frame(table(S.rem.loc))
E.rem.ct = data.frame(table(E.rem.loc))
I.rem.ct = data.frame(table(I.rem.loc))
for(f in 1:length(fams.rem.index)){
S.rem = 0
E.rem = 0
I.rem = 0
loc = pop[fams.rem.index[f], 3]
if(loc %in% S.rem.ct$S.rem.loc){S.rem = S.rem.ct$Freq[which(S.rem.ct$S.rem.loc==loc)]}
if(loc %in% E.rem.ct$E.rem.loc){E.rem = E.rem.ct$Freq[which(E.rem.ct$E.rem.loc==loc)]}
if(loc %in% I.rem.ct$I.rem.loc){I.rem = I.rem.ct$Freq[which(I.rem.ct$I.rem.loc==loc)]}
pop.out[fams.rem.index[f], 8] = pop.out[fams.rem.index[f], 8] - S.rem
pop.out[fams.rem.index[f], 9] = pop.out[fams.rem.index[f], 9] - E.rem
pop.out[fams.rem.index[f], 10] = pop.out[fams.rem.index[f], 10] - I.rem
pop.out[fams.rem.index[f], 1] = sum(pop.out[fams.rem.index[f], 8:10])
harvest.out.temp = c(time = thyme, loc = loc, S = S.rem, E = E.rem, I = I.rem)
harvest.out = rbind(harvest.out, harvest.out.temp)
} #end for loop to remove individuals from each cell
}#end of h.loc loop
pop.out = pop.out[which(pop.out[,1]>0),]
harvest.out = harvest.out[which(rowSums(harvest.out[,3:5, drop = FALSE])>0), , drop = FALSE]
}#end of h.time if
rownames(harvest.out) = NULL
pop.out = pop
harvest.out = matrix(c(0, 0, 0, 0, 0), nrow = 1)
if(thyme %in% h.time){
print("starting harvest")
h.loc = sample(dim(centroids)[1], h.permits, replace = TRUE)
for(q in 1:length(h.loc)){
h.loc.id.now = h.loc[q]
h.loc.xloc.now = centroids[h.loc.id.now, 1]
h.loc.yloc.now = centroids[h.loc.id.now, 2]
cells.in.h.radius = NULL
for(w in 1:dim(centroids)[1]){
potential.cell.x = centroids[w,1]
potential.cell.y = centroids[w,2]
distance = sqrt((h.loc.xloc.now - potential.cell.x)^2 + (h.loc.yloc.now - potential.cell.y)^2)
if(distance <= h.radius){
# print("true")
cells.in.h.radius = append(cells.in.h.radius, w)
}
}#end of distance calc loop
fams.in.radius = intersect(pop.out[,3], cells.in.h.radius)
# print(paste("removing", length(fams.in.radius), "families"))
fams.rem.index = which(pop[,3] %in% fams.in.radius)
pop.sub = pop[fams.rem.index, , drop = FALSE]
pop.classes = colSums(pop.sub[,8:10, drop = FALSE])
deer.in.sub = rep(c("S", "E", "I"), pop.classes)
S.in.sub = rep(pop.sub[,3], pop.sub[,8])
E.in.sub = rep(pop.sub[,3], pop.sub[,9])
I.in.sub = rep(pop.sub[,3], pop.sub[,10])
if(h.num > length(deer.in.sub)){h.num = length(deer.in.sub)}
rem.mems = sample(deer.in.sub, h.num, replace = FALSE)
S.rem = length(which(rem.mems == "S"))
E.rem = length(which(rem.mems == "E"))
I.rem = length(which(rem.mems == "I"))
S.rem.loc = sample(S.in.sub, S.rem, replace = FALSE)
E.rem.loc = sample(E.in.sub, E.rem, replace = FALSE)
I.rem.loc = sample(I.in.sub, I.rem, replace = FALSE)
S.rem.ct = data.frame(table(S.rem.loc))
E.rem.ct = data.frame(table(E.rem.loc))
I.rem.ct = data.frame(table(I.rem.loc))
for(f in 1:length(fams.rem.index)){
S.rem = 0
E.rem = 0
I.rem = 0
loc = pop[fams.rem.index[f], 3]
if(loc %in% S.rem.ct$S.rem.loc){S.rem = S.rem.ct$Freq[which(S.rem.ct$S.rem.loc==loc)]}
if(loc %in% E.rem.ct$E.rem.loc){E.rem = E.rem.ct$Freq[which(E.rem.ct$E.rem.loc==loc)]}
if(loc %in% I.rem.ct$I.rem.loc){I.rem = I.rem.ct$Freq[which(I.rem.ct$I.rem.loc==loc)]}
pop.out[fams.rem.index[f], 8] = pop.out[fams.rem.index[f], 8] - S.rem
pop.out[fams.rem.index[f], 9] = pop.out[fams.rem.index[f], 9] - E.rem
pop.out[fams.rem.index[f], 10] = pop.out[fams.rem.index[f], 10] - I.rem
pop.out[fams.rem.index[f], 1] = sum(pop.out[fams.rem.index[f], 8:10])
harvest.out.temp = c(time = thyme, loc = loc, S = S.rem, E = E.rem, I = I.rem)
harvest.out = rbind(harvest.out, harvest.out.temp)
} #end for loop to remove individuals from each cell
}#end of h.loc loop
pop.out = pop.out[which(pop.out[,1]>0),]
harvest.out = harvest.out[which(rowSums(harvest.out[,3:5, drop = FALSE])>0), , drop = FALSE]
}#end of h.time if
rownames(harvest.out) = NULL
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWDparms.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
plot(1:thyme, onerun[[4]])
plot(1:thyme, onerun[[2]])
plot(1:thyme, onerun[[1]])
plot(1:thyme, onerun[[9]][1])
plot(1:thyme, onerun[[9]][,1])
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/FOICWD.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/FOICWD.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
plot(1:thyme, onerun[[4]])
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWDparms.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
onerun[[14]]
onerun[[13]]
sur.data = aggregate(onerun[[13]], loc ~ num)
sur.data = aggregate(onerun[[13]], loc ~ num, sum)
sur.data = aggregate(onerun[[13]], num ~ loc, sum)
sur.data
subset(onerun, loc == 2)
subset(onerun, onerun[,1] == 2)
subset(onerun[[13]], loc == 2)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/parms_table.R", echo=TRUE)
all.parm.vals
all.parm.vals
all.parm.mean
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/parms_table.R", echo=TRUE)
length(all.parm.vals)
Harvest.parms.vals
paste(h.times)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/parms_table.R", echo=TRUE)
length(all.parm.vals)
length(all.parm.mean)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/parms_table.R", echo=TRUE)
onerun[[1]]
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/parms_table.R", echo=TRUE)
setwd("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts")
source(paste(getwd(), "/CWDSourcer.R", sep = ''))
init.model = init.CWD()
pop = init.model[[1]]
landscape.prions = init.model[[2]]
centroids = init.model[[3]]
onerun = SimulateOneRunCWD(pop, landscape.prions, centroids, track.pop = TRUE)
plot.landscape.meta(onerun, grid.xmax, grid.ymax)
dev.off()
setwd("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts")
source(paste(getwd(), "/CWDSourcer.R", sep = ''))
init.model = init.CWD()
pop = init.model[[1]]
landscape.prions = init.model[[2]]
centroids = init.model[[3]]
onerun = SimulateOneRunCWD(pop, landscape.prions, centroids, track.pop = TRUE)
ggplot() + geom_line(aes(1:thyme, y = onerun[[4]]))
debugSource("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
include_graphics("C:/Users/SIU856560341/Desktop/CWD_Modeling/Write-Up/Images/Meta_outbreak.gif")
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWD_plots.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWD_plots.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/CWD_plots.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
source("C:/Users/SIU856560341/Desktop/CWD_Modeling/Metapop_Model/Scripts/testing_run.R", echo=TRUE)
